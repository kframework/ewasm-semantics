#!/usr/bin/env bash

set -euo pipefail
shopt -s extglob

ewasm_dir="${EWASM_DIR:-$(dirname $0)}"
wasm_dir="${WASM_DIR:-$ewasm_dir/deps/wasm-semantics}"
build_dir="$ewasm_dir/.build"
defn_dir="$build_dir/defn"
lib_dir="$build_dir/local/lib"
haskell_backend_dir="$wasm_dir/deps/k/haskell-backend/src/main/native/haskell-backend"
k_release_dir="${K_RELEASE:-$wasm_dir/deps/k/k-distribution/target/release/k}"

export PATH="$k_release_dir/lib/native/linux:$k_release_dir/lib/native/linux64:$k_release_dir/bin/:$PATH"
export LD_LIBRARY_PATH="$k_release_dir/lib/native/linux64:$lib_dir:${LD_LIBRARY_PATH:-}"

test_logs="$build_dir/logs"
mkdir -p "$test_logs"
test_log="$test_logs/tests.log"

# Utilities
# ---------

notif() { echo "== $@" >&2 ; }
fatal() { echo "[FATAL] $@" ; exit 1 ; }

pretty_diff() {
    git --no-pager diff --no-index --ignore-all-space "$@"
}

# Runners
# -------

run_krun() {
    export K_OPTS=-Xss500m
    krun --directory "$backend_dir" "$run_file" "$@"
}

run_kast() {
    local output_mode

    if [ -z ${1+x} ]; then
        output_mode="kast"
    else
        output_mode=$1
        shift
    fi
    kast --directory "$backend_dir" "$run_file" --output "$output_mode" "$@"
}

run_prove() {
    export K_OPTS=-Xmx8G
    haskell_backend_command="$k_release_dir/bin/kore-exec"
    if $repl; then
        haskell_backend_command="$k_release_dir/bin/kore-repl --repl-script $ewasm_dir/kast.kscript"
    fi
    kprove --directory "$backend_dir" "$run_file" "$@" --haskell-backend-command "$haskell_backend_command"
}

# Main
# ----

usage() {
    echo "
    usage: $0 run        [--backend (llvm|haskell)]      <pgm>  <K args>*
           $0 kast       [--backend (llvm)]              <pgm>  <output format> <K args>*
           $0 prove      [--backend (haskell)] [--repl]  <spec> <K args>* -m <def_module>

       $0 run   : Run a single WebAssembly program
       $0 kast  : Parse a single WebAssembly program and output it in supported format
       $0 prove : Run a WebAssembly K proof

       Note: <pgm> is a path to a file containing a EWasm program.
             <spec> is a K specification to be proved.
             <K args> are any arguments you want to pass to K when executing/proving.
             <output format> is the format for Kast to output the term in.
             <def_module> is the module to take as axioms for verification.
"
}

usage_fatal() {
    usage
    fatal "$@"
}

[[ ! -z ${1:-} ]] || usage_fatal "Must supply a command to run."
if [[ "$1" == '--help' ]] || [ "$1" == 'help' ]; then
    usage
    exit 0
fi

run_command="$1"; shift

[[ ! -z ${1:-} ]] || usage_fatal "Must supply a file to work on."

backend="llvm"
repl=false
[[ ! "$run_command" == 'prove' ]] || backend='haskell'
args=()
while [[ $# -gt 0 ]]; do
    arg="$1"
    case $arg in
        --backend)    args+=("$arg" "$2") ; backend="$2"      ; shift 2 ;;
        --repl)       args+=("$arg")      ; repl=true         ; shift   ;;
        *)            break                                             ;;
    esac
done

! $repl || [[ "$backend" == "haskell" ]] || fatal "REPL option only available for Haskell backend."

backend_dir="$defn_dir/$backend"

# get the run file
[[ ! -z ${1:-} ]] || usage_fatal "Must supply a file to run on."
run_file="$1" ; shift
[[ -f "$run_file" ]] || fatal "File does not exist: $run_file"

case "$run_command-$backend" in
    run-@(llvm|haskell)  ) run_krun                        "$@" ;;
    kast-llvm            ) run_kast                        "$@" ;;
    prove-haskell        ) run_prove                       "$@" ;;
    *) usage_fatal "Unknown command on '$backend' backend: $run_command" ;;
esac
